--- platformio_override.ini      2020-08-04 12:31:17.000000000 +0000
+++ platformio_override.ini     2020-08-04 13:07:35.000000000 +0000
@@ -16,7 +16,7 @@
 ; *** Build/upload environment
 default_envs =
 ; *** Uncomment the line(s) below to select version(s)
-                tasmota
+                tasmota-CN
 ;                tasmota-debug
 ;                tasmota-ircustom
 ;                tasmota-minimal
@@ -38,9 +38,13 @@
 
 
 [common]
 platform_packages         = ${core.platform_packages}
 build_unflags             = ${core.build_unflags}
 build_flags               = ${core.build_flags}
+                            -Wl,-Tesp8266.flash.4m1m.ld
+; *** Use settings from file user_config_override.h
+                          -DUSE_CONFIG_OVERRIDE
+
 ; *** Optional Debug messages
 ;                            -DDEBUG_TASMOTA_CORE
 ;                            -DDEBUG_TASMOTA_DRIVER

--- tasmota/user_config_override.h       2020-09-16 15:52:52.623134135 +0800
+++ tasmota/user_config_override.h      2020-09-16 15:56:42.227141161 +0800
@@ -87,8 +87,108 @@
 
 */
 
+#ifdef USE_I2C
+  #define USE_BMP
+  #define USE_BH1750                             // [I2cDriver11] Enable BH1750 sensor (I2C address 0x23 or 0x5C) (+0k5 code)
+#endif
+
+#define USE_PMS5003
+
+#define DISPLAY_CONFIG  // -- Enable Display driver --
+
+#ifdef DISPLAY_CONFIG  // ---------------------------------------------------------------------------
+  #undef  USE_SPI
+  #define USE_DISPLAY
+
+ // #ifdef  USE_DISPLAY_MODES1TO5
+ //   #undef  USE_DISPLAY_MODES1TO5                // Disable display mode 1 to 5 in addition to mode 0
+ // #endif
+
+
+// Choose your display type by selecting the appropriate block of settings
+
+  // LCD display (I2C addresses 0x27 and 0x3F)
+  #ifndef USE_DISPLAY_LCD                      // Enable
+    #define USE_DISPLAY_LCD
+  #endif
+//  #ifdef USE_DISPLAY_LCD                       // Disable
+//    #undef USE_DISPLAY_LCD
+//  #endif
+
+  // OLED 128x64 display (I2C addresses 0x3C and 0x3D)
+//  #ifndef USE_DISPLAY_SSD1306                  // Enable
+//    #define USE_DISPLAY_SSD1306
+//  #endif
+  #ifdef USE_DISPLAY_SSD1306                   // Disable
+    #undef USE_DISPLAY_SSD1306
+  #endif
+
+  // OLED SH1106 display (I2C addresses 0x3C and 0x3D)
+//  #ifndef USE_DISPLAY_SSD1306                  // Enable
+//    #define USE_DISPLAY_SSD1306
+//  #endif
+  #ifdef USE_DISPLAY_SH1106                   // Disable
+    #undef USE_DISPLAY_SH1106
+  #endif
+
+  // 8x8 Matrix display
+//  #ifndef USE_DISPLAY_MATRIX                   // Enable
+//    #define USE_DISPLAY_MATRIX
+//  #endif
+//  #ifdef USE_DISPLAY_MATRIX                    // Disable
+//    #undef USE_DISPLAY_MATRIX
+//  #endif
+
+  // [DisplayModel 4] ILI9341 TFT 480x320 display (+19k code)
+//  #ifndef USE_DISPLAY_ILI9341                  // Enable
+//    #define USE_DISPLAY_ILI9341
+//    #define USE_SPI
+//  #endif
+  #ifdef USE_DISPLAY_ILI9341                   // Disable
+    #undef USE_DISPLAY_ILI9341
+  #endif
+
+  // e-paper display (choose 29 or 42)
+//  #ifndef USE_DISPLAY_EPAPER                   // Enable
+//    #define USE_SPI
+//    #define SHOW_SPLASH
+//    #define USE_DISPLAY_EPAPER
+//    #define USE_DISPLAY_EPAPER_29                // [DisplayModel 5] e-paper 2.9 inch display (+19k code)
+//    #define USE_DISPLAY_EPAPER_42                // [DisplayModel 6] e-paper 4.2 inch display
+//  #endif
+  #ifdef  USE_DISPLAY_EPAPER                   // Disable
+    #undef USE_DISPLAY_EPAPER
+    #undef USE_DISPLAY_EPAPER_29
+    #undef USE_DISPLAY_EPAPER_42
+  #endif
+
+  // [DisplayModel 8] ILI9488
+//  #ifndef USE_DISPLAY_ILI9488                  // Enable
+//    #define USE_SPI
+//    #define USE_DISPLAY_ILI9488
+//  #endif
+  #ifdef USE_DISPLAY_ILI9488                   // Disable
+    #undef USE_DISPLAY_ILI9488
+  #endif
+
+  // [DisplayModel 9] SSD1351
+//  #ifndef USE_DISPLAY_SSD1351                  // Enable
+//    #define USE_SPI
+//    #define USE_DISPLAY_SSD1351
+//  #endif
+  #ifdef USE_DISPLAY_SSD1351                   // Disable
+    #undef USE_DISPLAY_SSD1351
+  #endif
+
+  // [DisplayModel 10] RA8876
+//  #ifndef USE_DISPLAY_RA8876                   // Enable
+//    #define USE_SPI
+//    #define USE_DISPLAY_RA8876
+//  #endif
+  #ifdef USE_DISPLAY_RA8876                    // Disable
+    #undef USE_DISPLAY_RA8876
+  #endif
 
-
-
+#endif  // DISPLAY_CONFIG ----------------------------------------------------------------------------
 
 #endif  // _USER_CONFIG_OVERRIDE_H_

--- tasmota/xsns_18_pms5003.ino
+++ tasmota/xsns_18_pms5003.ino
@@ -48,6 +48,7 @@ struct PMS5003 {
   uint8_t valid = 0;
   uint8_t wake_mode = 1;
   uint8_t ready = 1;
+  uint8_t read_timeout = 0;
 } Pms;
 
 enum PmsCommands
@@ -154,7 +155,6 @@ bool PmsReadData(void)
 #else
   memcpy((void *)&pms_data, (void *)buffer_u16, 30);
 #endif  // PMS_MODEL_PMS3003
-  Pms.valid = 10;
 
   return true;
 }
@@ -204,10 +204,13 @@ void PmsSecond(void)                 // Every second
     if ((Settings.pms_wake_interval - Pms.time <= WARMUP_PERIOD) && !Pms.wake_mode) {
       // wakeup sensor WARMUP_PERIOD before read interval
       Pms.wake_mode = 1;
+      AddLog_P(LOG_LEVEL_DEBUG, PSTR("PMS: PmsSendCmd(CMD_WAKEUP)"));
       PmsSendCmd(CMD_WAKEUP);
     }
     if (Pms.time >= Settings.pms_wake_interval) {
       // sensor is awake and warmed up, set up for reading
+      while(PmsSerial->read() >= 0){}
+      AddLog_P(LOG_LEVEL_DEBUG, PSTR("PMS: PmsSendCmd(CMD_READ_DATA)"));
       PmsSendCmd(CMD_READ_DATA);
       Pms.ready = 1;
       Pms.time = 0;
@@ -216,6 +219,7 @@ void PmsSecond(void)                 // Every second
 
   if (Pms.ready) {
     if (PmsReadData()) {
+      Pms.read_timeout = 0;
       Pms.valid = 10;
       if (Settings.pms_wake_interval >= MIN_INTERVAL_PERIOD) {
         PmsSendCmd(CMD_SLEEP);
@@ -223,6 +227,7 @@ void PmsSecond(void)                 // Every second
         Pms.ready = 0;
       }
     } else {
+      Pms.read_timeout++;
       if (Pms.valid) {
         Pms.valid--;
         if (Settings.pms_wake_interval >= MIN_INTERVAL_PERIOD) {
@@ -231,6 +236,16 @@ void PmsSecond(void)                 // Every second
         }
       }
     }
+    if (Pms.read_timeout == 5) {
+      AddLog_P(LOG_LEVEL_DEBUG, PSTR("PMS: timeout"));
+      if (Settings.pms_wake_interval >= MIN_INTERVAL_PERIOD) {
+        // Passive Mode
+        PmsSendCmd(CMD_MODE_PASSIVE);
+        Pms.wake_mode = 0;
+        Pms.read_timeout = 0;
+        Pms.time = Settings.pms_wake_interval - WARMUP_PERIOD - 1;
+      }
+    }
   }
 }
 
